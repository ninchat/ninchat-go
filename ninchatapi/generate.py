import cStringIO as stringio
import os
import sys

import ninchat.api

requiredtypes = {
	"bool":         "bool",
	"float":        "float64",
	"int":          "int",
	"object":       "map[string]interface{}",
	"string":       "string",
	"string array": "[]string",
	"time":         "int",
}

optionaltypes = {
	"bool":         "bool",
	"float":        "*float64",
	"int":          "*int",
	"object":       "map[string]interface{}",
	"string":       "*string",
	"string array": "[]string",
	"time":         "*int",
}

checks = {
	"bool":         "x",
	"float":        "x != nil",
	"int":          "x != nil",
	"object":       "x != nil",
	"string":       "x != nil",
	"string array": "len(x) > 0",
	"time":         "x != nil",
}

evals = {
	"bool":         "x",
	"float":        "*x",
	"int":          "*x",
	"object":       "x",
	"string":       "*x",
	"string array": "x",
	"time":         "*x",
}

payloadactions = {
	"send_message",
	"update_user",
}

payloadevents = {
	"message_received",
}

attrobjects = [
	(ninchat.api.attrs.channel,        "Channel",        "channel"),
	(ninchat.api.attrs.channelmember,  "ChannelMember",  "channel membership"),
	(ninchat.api.attrs.dialoguemember, "DialogueMember", "dialogue membership"),
	(ninchat.api.attrs.identity,       "Identity",       "identity"),
	(ninchat.api.attrs.puppet,         "Puppet",         "puppet"),
	(ninchat.api.attrs.queue,          "Queue",          "queue"),
	(ninchat.api.attrs.realm,          "Realm",          "realm"),
	(ninchat.api.attrs.realmmember,    "RealmMember",    "realm membership"),
	(ninchat.api.attrs.user,           "User",           "user"),
]

unaryreplies = {
	"accept_audience": "dialogue_updated",
	"add_member": "member_joined",          # pseudo-event implemented manually
	"close_session": None,
	"create_access": "access_created",
	"create_channel": "channel_joined",
	"create_identity": "identity_created",
	"create_master_key": "master_key_created",
	"create_queue": "queue_created",
	"create_realm": "realm_joined",
	"delete_identity": "identity_deleted",
	"delete_master_key": "master_key_deleted",
	"delete_queue": "queue_deleted",
	"delete_realm": "realm_deleted",
	"delete_user": "user_deleted",
	"describe_access": "access_found",
	"describe_channel": "channel_found",
	"describe_file": "file_found",
	"describe_identity": "identity_found",
	"describe_master": "master_found",
	"describe_queue": "queue_found",
	"describe_realm": "realm_found",
	"describe_realm_queues": "realm_queues_found",
	"describe_user": "user_found",
	"discard_history": "history_discarded",
	"follow_channel": "channel_found",
	"join_channel": "channel_joined",
	"load_history": None,
	"part_channel": "channel_parted",
	"ping": "pong",
	"remove_member": "member_parted",       # pseudo-event implemented manually
	"request_audience": "audience_enqueued",
	"request_identity_auth_reset_access": "access_created",
	"request_identity_verify_access": "access_created",
	"reset_identity_auth": "identity_updated",
	"resume_session": None,
	"search": None,
	"send_access": "access_found",
	"send_file": "message_received",
	"send_message": "message_received",
	"update_channel": "channel_updated",
	"update_dialogue": "dialogue_updated",
	"update_identity": "identity_updated",
	"update_identity_auth": "identity_updated",
	"update_member": "member_updated",      # pseudo-event implemented manually
	"update_message": "message_updated",
	"update_queue": "queue_updated",
	"update_realm": "realm_updated",
	"update_session": None,
	"update_user": "user_updated",
	"verify_identity": "identity_updated",
}

class Output(object):

	def __init__(self, name):
		self.filename = os.path.join("ninchatapi", name + "_gen.go")

	def __enter__(self):
		self.buf = stringio.StringIO()

		self.orig_stdout = sys.stdout
		sys.stdout = self.buf

	def __exit__(self, exc_type, exc_value, traceback):
		assert sys.stdout is self.buf
		sys.stdout = self.orig_stdout

		if not exc_type:
			with open(self.filename, "w") as f:
				f.write(self.buf.getvalue())

def main():
	with Output("actions"):
		print_header()

		print
		print 'import "errors"'
		print 'import ninchat ".."'

		for action in sorted(ninchat.api.actions.values(), key=lambda a: a.name):
			if action.name != "create_session":
				print_action(action)

	with Output("events"):
		print_header()

		print
		print 'import ninchat ".."'

		for event in sorted(ninchat.api.events.values(), key=lambda e: e.name):
			print_event(event)

	with Output("attrs"):
		print_header()

		for attrs, objectname, commentname in attrobjects:
			print_attrs(attrs, objectname, commentname)

def print_header():
	print 'package ninchatapi'
	print
	print '// THIS FILE IS AUTO GENERATED BY generate.py - DO NOT EDIT BY HAND!'
	print '// Definitions can be found at: https://github.com/ninchat/ninchat-api/tree/master/json'

def print_action(action):
	print
	print '// {} holds parameters for the `{}` action.'.format(title(action.name), action.name)
	print 'type {} struct {{'.format(title(action.name))

	action_id = action.params.get("action_id")
	if action_id and not action_id.required:
		print '  ActionIdDisabled bool'

	print_params(action.params, require=False)

	payload = action.name in payloadactions
	if payload:
		print '  Payload [][]byte'

	print '}'
	print
	print 'func (*{}) String() string {{'.format(title(action.name))
	print '  return "{}"'.format(action.name)
	print '}'
	print

	print 'func (action *{}) newClientAction() (clientAction *ninchat.Action, err error) {{'.format(title(action.name))
	print '  clientAction = &ninchat.Action{'
	print '    Params: map[string]interface{}{'
	print '      "action": "{}",'.format(action.name)

	if not action_id:
		print '      "action_id": nil,'

	print '    },'

	if payload:
		print '    Payload: action.Payload,'

	print '  }'

	if action_id and not action_id.required:
		print
		print '  if action.ActionIdDisabled {'
		print '    clientAction.Params["action_id"] = nil'
		print '  }'

	for _, p in sorted(action.params.items()):
		if p.name != "action_id":
			print
			print '  if x := action.{}; {} {{'.format(title(p.name), checks[p.type])
			print '    clientAction.Params["{}"] = {}'.format(p.name, evals[p.type])

			if p.required:
				print '  } else {'
				print '    return nil, errors.New("{} requires {} parameter")'.format(action.name, p.name)

			print '  }'

	print
	print '  return'
	print '}'

	reply = unaryreplies[action.name]
	if reply:
		print
		print '// Call the `{}` action synchronously.'.format(action.name)
		print 'func (action *{}) Call(session *ninchat.Session) (reply *{}, err error) {{'.format(title(action.name), title(reply))
		print '  var buf {}'.format(title(reply))
		print
		print '  ok, err := unaryCall(session, action, &buf)'
		print '  if err != nil {'
		print '    return nil, err'
		print '  }'
		print
		print '  if ok {'
		print '    return &buf, nil'
		print '  }'
		print
		print '  return nil, nil'
		print '}'

def print_event(event):
	print
	print '// {} event parameters.'.format(title(event.name))
	print 'type {} struct {{'.format(title(event.name))

	print_params(event.params, require=True)

	payload = event.name in payloadevents
	if payload:
		print '  Payload [][]byte'

	print '}'
	print
	print 'func (*{}) String() string {{'.format(title(event.name))
	print '  return "{}"'.format(event.name)
	print '}'
	print
	print 'func (target *{}) init(clientEvent *ninchat.Event) error {{'.format(title(event.name))
	print '  if clientEvent.String() != "{}" {{'.format(event.name)
	print '    return &EventError{clientEvent}'
	print '  }'

	params = event.params.copy()
	try:
		del params["action_id"]
	except KeyError:
		pass

	if params:
		print
		print 'source := clientEvent.Params'

		print_init_params(params, require=True)

	if payload:
		print
		print 'target.Payload = clientEvent.Payload'

	print
	print '  return nil'
	print '}'

def print_init_params(params, require, objfmt="{}"):
	for _, p in sorted(params.items()):
		print
		print 'if x := source["{}"]; x != nil {{'.format(p.name)

		if p.type == "bool":
			print 'target.{} = true'.format(title(p.name))
		elif p.type == "object":
			print 'if y, ok := x.(map[string]interface{}); ok {'

			if p.name == "member_attrs" or p.name.endswith("_metadata") or p.name.endswith("_settings"):
				print 'target.{} = y'.format(title(p.name))
			else:
				print 'target.{} = new({})'.format(title(p.name), objfmt.format(title(p.name)))
				print 'target.{}.init(y)'.format(title(p.name))

			print '}'
		elif p.type == "string array":
			print 'if y, ok := x.([]string); ok {'
			print '  target.{} = y'.format(title(p.name))
			print '}'
		else:
			if require and p.required:
				expr = "y"
			else:
				expr = "&y"

			print 'if y, ok := x.({}); ok {{'.format(requiredtypes[p.type], p.name)
			print '  target.{} = {}'.format(title(p.name), expr)
			print '}'

		print '}'

def print_attrs(attrs, objectname, commentname):
	print
	print '// {}Attrs holds {} attributes.'.format(objectname, commentname)
	print 'type {}Attrs struct {{'.format(objectname)

	for _, a in sorted(attrs.items()):
		if a.type == "object":
			t = '*{}{}Attr'.format(objectname, title(a.name))
		else:
			t = optionaltypes[a.type]

		print '  {} {} `json:"{},omitempty"`'.format(title(a.name), t, a.name)

	print '}'
	print
	print 'func (target *{}Attrs) init(source map[string]interface{{}}) {{'.format(objectname)

	print_init_params(attrs, require=False, objfmt=objectname + "{}Attr")

	print '}'

def print_params(params, require):
	for _, p in sorted(params.items()):
		if p.name != "action_id":
			option = ''

			if p.name == "member_attrs":
				t = "interface{}"
			elif p.type == "object" and not (p.name.endswith("_metadata") or p.name.endswith("_settings")):
				t = "*" + title(p.name)
				if not (require and p.required):
					option = ",omitempty"
			elif require and p.required:
				t = requiredtypes[p.type]
			else:
				t = optionaltypes[p.type]
				option = ",omitempty"

			print '  {} {} `json:"{}{}"`'.format(title(p.name), t, p.name, option)

def title(s):
	return s.title().replace("_", "")

if __name__ == "__main__":
	main()
