package ninchatapi

// THIS FILE IS AUTO-GENERATED BY generate.py - DO NOT EDIT BY HAND!

// ChannelAttrs.  https://ninchat.com/api/v2#channel
type ChannelAttrs struct {
	Autosilence             bool     `json:"autosilence,omitempty"`
	BlacklistedMessageTypes []string `json:"blacklisted_message_types,omitempty"`
	DisclosedSince          *int     `json:"disclosed_since,omitempty"`
	Followable              bool     `json:"followable,omitempty"`
	Name                    *string  `json:"name,omitempty"`
	OwnerId                 *string  `json:"owner_id,omitempty"`
	Private                 bool     `json:"private,omitempty"`
	Public                  bool     `json:"public,omitempty"`
	Ratelimit               *string  `json:"ratelimit,omitempty"`
	Suspended               bool     `json:"suspended,omitempty"`
	Topic                   *string  `json:"topic,omitempty"`
	VerifiedJoin            bool     `json:"verified_join,omitempty"`
}

// MergeFrom fills in the parameters specified by the source.
func (target *ChannelAttrs) MergeFrom(source map[string]interface{}) {

	if x := source["autosilence"]; x != nil {
		target.Autosilence = true
	}

	if x := source["blacklisted_message_types"]; x != nil {
		if y, ok := x.([]string); ok {
			target.BlacklistedMessageTypes = y
		}
	}

	if x := source["disclosed_since"]; x != nil {
		if y, ok := x.(int); ok {
			target.DisclosedSince = &y
		}
	}

	if x := source["followable"]; x != nil {
		target.Followable = true
	}

	if x := source["name"]; x != nil {
		if y, ok := x.(string); ok {
			target.Name = &y
		}
	}

	if x := source["owner_id"]; x != nil {
		if y, ok := x.(string); ok {
			target.OwnerId = &y
		}
	}

	if x := source["private"]; x != nil {
		target.Private = true
	}

	if x := source["public"]; x != nil {
		target.Public = true
	}

	if x := source["ratelimit"]; x != nil {
		if y, ok := x.(string); ok {
			target.Ratelimit = &y
		}
	}

	if x := source["suspended"]; x != nil {
		target.Suspended = true
	}

	if x := source["topic"]; x != nil {
		if y, ok := x.(string); ok {
			target.Topic = &y
		}
	}

	if x := source["verified_join"]; x != nil {
		target.VerifiedJoin = true
	}
}

// ChannelMemberAttrs.  https://ninchat.com/api/v2#channel-membership
type ChannelMemberAttrs struct {
	Operator bool `json:"operator,omitempty"`
	Silenced bool `json:"silenced,omitempty"`
	Since    *int `json:"since,omitempty"`
}

// MergeFrom fills in the parameters specified by the source.
func (target *ChannelMemberAttrs) MergeFrom(source map[string]interface{}) {

	if x := source["operator"]; x != nil {
		target.Operator = true
	}

	if x := source["silenced"]; x != nil {
		target.Silenced = true
	}

	if x := source["since"]; x != nil {
		if y, ok := x.(int); ok {
			target.Since = &y
		}
	}
}

// DialogueMemberAttrs.  https://ninchat.com/api/v2#dialogue-membership
type DialogueMemberAttrs struct {
	QueueId *string `json:"queue_id,omitempty"`
	Rating  *int    `json:"rating,omitempty"`
	Writing bool    `json:"writing,omitempty"`
}

// MergeFrom fills in the parameters specified by the source.
func (target *DialogueMemberAttrs) MergeFrom(source map[string]interface{}) {

	if x := source["queue_id"]; x != nil {
		if y, ok := x.(string); ok {
			target.QueueId = &y
		}
	}

	if x := source["rating"]; x != nil {
		if y, ok := x.(int); ok {
			target.Rating = &y
		}
	}

	if x := source["writing"]; x != nil {
		target.Writing = true
	}
}

// IdentityAttrs.  https://ninchat.com/api/v2#identity
type IdentityAttrs struct {
	Auth     bool `json:"auth,omitempty"`
	Blocked  bool `json:"blocked,omitempty"`
	Pending  bool `json:"pending,omitempty"`
	Public   bool `json:"public,omitempty"`
	Rejected bool `json:"rejected,omitempty"`
}

// MergeFrom fills in the parameters specified by the source.
func (target *IdentityAttrs) MergeFrom(source map[string]interface{}) {

	if x := source["auth"]; x != nil {
		target.Auth = true
	}

	if x := source["blocked"]; x != nil {
		target.Blocked = true
	}

	if x := source["pending"]; x != nil {
		target.Pending = true
	}

	if x := source["public"]; x != nil {
		target.Public = true
	}

	if x := source["rejected"]; x != nil {
		target.Rejected = true
	}
}

// PuppetAttrs.  https://ninchat.com/api/v2#puppet
type PuppetAttrs struct {
	Name *string `json:"name,omitempty"`
}

// MergeFrom fills in the parameters specified by the source.
func (target *PuppetAttrs) MergeFrom(source map[string]interface{}) {

	if x := source["name"]; x != nil {
		if y, ok := x.(string); ok {
			target.Name = &y
		}
	}
}

// QueueAttrs.  https://ninchat.com/api/v2#queue
type QueueAttrs struct {
	Capacity  *int    `json:"capacity,omitempty"`
	Closed    bool    `json:"closed,omitempty"`
	Length    *int    `json:"length,omitempty"`
	Name      *string `json:"name,omitempty"`
	Suspended bool    `json:"suspended,omitempty"`
}

// MergeFrom fills in the parameters specified by the source.
func (target *QueueAttrs) MergeFrom(source map[string]interface{}) {

	if x := source["capacity"]; x != nil {
		if y, ok := x.(int); ok {
			target.Capacity = &y
		}
	}

	if x := source["closed"]; x != nil {
		target.Closed = true
	}

	if x := source["length"]; x != nil {
		if y, ok := x.(int); ok {
			target.Length = &y
		}
	}

	if x := source["name"]; x != nil {
		if y, ok := x.(string); ok {
			target.Name = &y
		}
	}

	if x := source["suspended"]; x != nil {
		target.Suspended = true
	}
}

// RealmAttrs.  https://ninchat.com/api/v2#realm
type RealmAttrs struct {
	Name         *string                `json:"name,omitempty"`
	OwnerAccount *RealmOwnerAccountAttr `json:"owner_account,omitempty"`
	OwnerId      *string                `json:"owner_id,omitempty"`
	Suspended    bool                   `json:"suspended,omitempty"`
	Theme        *RealmThemeAttr        `json:"theme,omitempty"`
}

// MergeFrom fills in the parameters specified by the source.
func (target *RealmAttrs) MergeFrom(source map[string]interface{}) {

	if x := source["name"]; x != nil {
		if y, ok := x.(string); ok {
			target.Name = &y
		}
	}

	if x := source["owner_account"]; x != nil {
		if y, ok := x.(map[string]interface{}); ok {
			target.OwnerAccount = new(RealmOwnerAccountAttr)
			target.OwnerAccount.MergeFrom(y)
		}
	}

	if x := source["owner_id"]; x != nil {
		if y, ok := x.(string); ok {
			target.OwnerId = &y
		}
	}

	if x := source["suspended"]; x != nil {
		target.Suspended = true
	}

	if x := source["theme"]; x != nil {
		if y, ok := x.(map[string]interface{}); ok {
			target.Theme = new(RealmThemeAttr)
			target.Theme.MergeFrom(y)
		}
	}
}

// RealmMemberAttrs.  https://ninchat.com/api/v2#realm-membership
type RealmMemberAttrs struct {
	Operator bool `json:"operator,omitempty"`
}

// MergeFrom fills in the parameters specified by the source.
func (target *RealmMemberAttrs) MergeFrom(source map[string]interface{}) {

	if x := source["operator"]; x != nil {
		target.Operator = true
	}
}

// UserAttrs.  https://ninchat.com/api/v2#user
type UserAttrs struct {
	Admin     bool          `json:"admin,omitempty"`
	Connected bool          `json:"connected,omitempty"`
	Deleted   bool          `json:"deleted,omitempty"`
	Guest     bool          `json:"guest,omitempty"`
	Iconurl   *string       `json:"iconurl,omitempty"`
	Idle      *int          `json:"idle,omitempty"`
	Info      *UserInfoAttr `json:"info,omitempty"`
	Name      *string       `json:"name,omitempty"`
	Realname  *string       `json:"realname,omitempty"`
}

// MergeFrom fills in the parameters specified by the source.
func (target *UserAttrs) MergeFrom(source map[string]interface{}) {

	if x := source["admin"]; x != nil {
		target.Admin = true
	}

	if x := source["connected"]; x != nil {
		target.Connected = true
	}

	if x := source["deleted"]; x != nil {
		target.Deleted = true
	}

	if x := source["guest"]; x != nil {
		target.Guest = true
	}

	if x := source["iconurl"]; x != nil {
		if y, ok := x.(string); ok {
			target.Iconurl = &y
		}
	}

	if x := source["idle"]; x != nil {
		if y, ok := x.(int); ok {
			target.Idle = &y
		}
	}

	if x := source["info"]; x != nil {
		if y, ok := x.(map[string]interface{}); ok {
			target.Info = new(UserInfoAttr)
			target.Info.MergeFrom(y)
		}
	}

	if x := source["name"]; x != nil {
		if y, ok := x.(string); ok {
			target.Name = &y
		}
	}

	if x := source["realname"]; x != nil {
		if y, ok := x.(string); ok {
			target.Realname = &y
		}
	}
}
