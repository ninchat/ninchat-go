package ninchatapi

// THIS FILE IS AUTO GENERATED BY generate.py - DO NOT EDIT BY HAND!
// Definitions can be found at: https://github.com/ninchat/ninchat-api/tree/master/json

import (
	"errors"

	"github.com/ninchat/ninchat-go"
)

// AcceptAudience action.
type AcceptAudience struct {
	QueueId *string `json:"queue_id,omitempty"`
}

func (*AcceptAudience) String() string {
	return "accept_audience"
}

func (action *AcceptAudience) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "accept_audience",
		},
	}

	if x := action.QueueId; x != nil {
		clientAction.Params["queue_id"] = *x
	} else {
		return nil, errors.New("accept_audience requires queue_id parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *AcceptAudience) Invoke(session *ninchat.Session) (reply *DialogueUpdated, err error) {
	var buf DialogueUpdated

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// AddMember action.
type AddMember struct {
	QueueId *string `json:"queue_id,omitempty"`
	UserId  *string `json:"user_id,omitempty"`
}

func (*AddMember) String() string {
	return "add_member"
}

func (action *AddMember) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "add_member",
		},
	}

	if x := action.QueueId; x != nil {
		clientAction.Params["queue_id"] = *x
	} else {
		return nil, errors.New("add_member requires queue_id parameter")
	}

	if x := action.UserId; x != nil {
		clientAction.Params["user_id"] = *x
	} else {
		return nil, errors.New("add_member requires user_id parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *AddMember) Invoke(session *ninchat.Session) (reply *MemberJoined, err error) {
	var buf MemberJoined

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// CloseSession action.
type CloseSession struct {
}

func (*CloseSession) String() string {
	return "close_session"
}

func (action *CloseSession) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action":    "close_session",
			"action_id": nil,
		},
	}

	return
}

// CreateAccess action.
type CreateAccess struct {
	AccessType  *string `json:"access_type,omitempty"`
	ChannelId   *string `json:"channel_id,omitempty"`
	RealmMember bool    `json:"realm_member,omitempty"`
	UserId      *string `json:"user_id,omitempty"`
}

func (*CreateAccess) String() string {
	return "create_access"
}

func (action *CreateAccess) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "create_access",
		},
	}

	if x := action.AccessType; x != nil {
		clientAction.Params["access_type"] = *x
	} else {
		return nil, errors.New("create_access requires access_type parameter")
	}

	if x := action.ChannelId; x != nil {
		clientAction.Params["channel_id"] = *x
	}

	if x := action.RealmMember; x {
		clientAction.Params["realm_member"] = x
	}

	if x := action.UserId; x != nil {
		clientAction.Params["user_id"] = *x
	}

	return
}

// Invoke the action synchronously.
func (action *CreateAccess) Invoke(session *ninchat.Session) (reply *AccessCreated, err error) {
	var buf AccessCreated

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// CreateChannel action.
type CreateChannel struct {
	ChannelAttrs *ChannelAttrs `json:"channel_attrs,omitempty"`
	RealmId      *string       `json:"realm_id,omitempty"`
}

func (*CreateChannel) String() string {
	return "create_channel"
}

func (action *CreateChannel) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "create_channel",
		},
	}

	if x := action.ChannelAttrs; x != nil {
		clientAction.Params["channel_attrs"] = x
	}

	if x := action.RealmId; x != nil {
		clientAction.Params["realm_id"] = *x
	}

	return
}

// Invoke the action synchronously.
func (action *CreateChannel) Invoke(session *ninchat.Session) (reply *ChannelJoined, err error) {
	var buf ChannelJoined

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// CreateIdentity action.
type CreateIdentity struct {
	IdentityAttrs   *IdentityAttrs `json:"identity_attrs,omitempty"`
	IdentityAuthNew *string        `json:"identity_auth_new,omitempty"`
	IdentityName    *string        `json:"identity_name,omitempty"`
	IdentityType    *string        `json:"identity_type,omitempty"`
}

func (*CreateIdentity) String() string {
	return "create_identity"
}

func (action *CreateIdentity) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "create_identity",
		},
	}

	if x := action.IdentityAttrs; x != nil {
		clientAction.Params["identity_attrs"] = x
	}

	if x := action.IdentityAuthNew; x != nil {
		clientAction.Params["identity_auth_new"] = *x
	}

	if x := action.IdentityName; x != nil {
		clientAction.Params["identity_name"] = *x
	} else {
		return nil, errors.New("create_identity requires identity_name parameter")
	}

	if x := action.IdentityType; x != nil {
		clientAction.Params["identity_type"] = *x
	} else {
		return nil, errors.New("create_identity requires identity_type parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *CreateIdentity) Invoke(session *ninchat.Session) (reply *IdentityCreated, err error) {
	var buf IdentityCreated

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// CreateMasterKey action.
type CreateMasterKey struct {
}

func (*CreateMasterKey) String() string {
	return "create_master_key"
}

func (action *CreateMasterKey) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "create_master_key",
		},
	}

	return
}

// Invoke the action synchronously.
func (action *CreateMasterKey) Invoke(session *ninchat.Session) (reply *MasterKeyCreated, err error) {
	var buf MasterKeyCreated

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// CreateQueue action.
type CreateQueue struct {
	QueueAttrs *QueueAttrs `json:"queue_attrs,omitempty"`
	RealmId    *string     `json:"realm_id,omitempty"`
}

func (*CreateQueue) String() string {
	return "create_queue"
}

func (action *CreateQueue) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "create_queue",
		},
	}

	if x := action.QueueAttrs; x != nil {
		clientAction.Params["queue_attrs"] = x
	} else {
		return nil, errors.New("create_queue requires queue_attrs parameter")
	}

	if x := action.RealmId; x != nil {
		clientAction.Params["realm_id"] = *x
	} else {
		return nil, errors.New("create_queue requires realm_id parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *CreateQueue) Invoke(session *ninchat.Session) (reply *QueueCreated, err error) {
	var buf QueueCreated

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// CreateRealm action.
type CreateRealm struct {
	ChannelAttrs *ChannelAttrs `json:"channel_attrs,omitempty"`
	RealmAttrs   *RealmAttrs   `json:"realm_attrs,omitempty"`
}

func (*CreateRealm) String() string {
	return "create_realm"
}

func (action *CreateRealm) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "create_realm",
		},
	}

	if x := action.ChannelAttrs; x != nil {
		clientAction.Params["channel_attrs"] = x
	}

	if x := action.RealmAttrs; x != nil {
		clientAction.Params["realm_attrs"] = x
	}

	return
}

// Invoke the action synchronously.
func (action *CreateRealm) Invoke(session *ninchat.Session) (reply *RealmJoined, err error) {
	var buf RealmJoined

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// DeleteIdentity action.
type DeleteIdentity struct {
	IdentityAuth *string `json:"identity_auth,omitempty"`
	IdentityName *string `json:"identity_name,omitempty"`
	IdentityType *string `json:"identity_type,omitempty"`
}

func (*DeleteIdentity) String() string {
	return "delete_identity"
}

func (action *DeleteIdentity) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "delete_identity",
		},
	}

	if x := action.IdentityAuth; x != nil {
		clientAction.Params["identity_auth"] = *x
	}

	if x := action.IdentityName; x != nil {
		clientAction.Params["identity_name"] = *x
	} else {
		return nil, errors.New("delete_identity requires identity_name parameter")
	}

	if x := action.IdentityType; x != nil {
		clientAction.Params["identity_type"] = *x
	} else {
		return nil, errors.New("delete_identity requires identity_type parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *DeleteIdentity) Invoke(session *ninchat.Session) (reply *IdentityDeleted, err error) {
	var buf IdentityDeleted

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// DeleteMasterKey action.
type DeleteMasterKey struct {
	MasterKeyId     *string `json:"master_key_id,omitempty"`
	MasterKeySecret *string `json:"master_key_secret,omitempty"`
	UserAuth        *string `json:"user_auth,omitempty"`
}

func (*DeleteMasterKey) String() string {
	return "delete_master_key"
}

func (action *DeleteMasterKey) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "delete_master_key",
		},
	}

	if x := action.MasterKeyId; x != nil {
		clientAction.Params["master_key_id"] = *x
	} else {
		return nil, errors.New("delete_master_key requires master_key_id parameter")
	}

	if x := action.MasterKeySecret; x != nil {
		clientAction.Params["master_key_secret"] = *x
	}

	if x := action.UserAuth; x != nil {
		clientAction.Params["user_auth"] = *x
	}

	return
}

// Invoke the action synchronously.
func (action *DeleteMasterKey) Invoke(session *ninchat.Session) (reply *MasterKeyDeleted, err error) {
	var buf MasterKeyDeleted

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// DeleteQueue action.
type DeleteQueue struct {
	QueueId *string `json:"queue_id,omitempty"`
}

func (*DeleteQueue) String() string {
	return "delete_queue"
}

func (action *DeleteQueue) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "delete_queue",
		},
	}

	if x := action.QueueId; x != nil {
		clientAction.Params["queue_id"] = *x
	} else {
		return nil, errors.New("delete_queue requires queue_id parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *DeleteQueue) Invoke(session *ninchat.Session) (reply *QueueDeleted, err error) {
	var buf QueueDeleted

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// DeleteRealm action.
type DeleteRealm struct {
	RealmId *string `json:"realm_id,omitempty"`
}

func (*DeleteRealm) String() string {
	return "delete_realm"
}

func (action *DeleteRealm) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "delete_realm",
		},
	}

	if x := action.RealmId; x != nil {
		clientAction.Params["realm_id"] = *x
	} else {
		return nil, errors.New("delete_realm requires realm_id parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *DeleteRealm) Invoke(session *ninchat.Session) (reply *RealmDeleted, err error) {
	var buf RealmDeleted

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// DeleteUser action.
type DeleteUser struct {
	UserAuth *string `json:"user_auth,omitempty"`
}

func (*DeleteUser) String() string {
	return "delete_user"
}

func (action *DeleteUser) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "delete_user",
		},
	}

	if x := action.UserAuth; x != nil {
		clientAction.Params["user_auth"] = *x
	} else {
		return nil, errors.New("delete_user requires user_auth parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *DeleteUser) Invoke(session *ninchat.Session) (reply *UserDeleted, err error) {
	var buf UserDeleted

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// DescribeAccess action.
type DescribeAccess struct {
	ActionIdDisabled bool
	AccessKey        *string `json:"access_key,omitempty"`
}

func (*DescribeAccess) String() string {
	return "describe_access"
}

func (action *DescribeAccess) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "describe_access",
		},
	}

	if action.ActionIdDisabled {
		clientAction.Params["action_id"] = nil
	}

	if x := action.AccessKey; x != nil {
		clientAction.Params["access_key"] = *x
	} else {
		return nil, errors.New("describe_access requires access_key parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *DescribeAccess) Invoke(session *ninchat.Session) (reply *AccessFound, err error) {
	var buf AccessFound

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// DescribeChannel action.
type DescribeChannel struct {
	ChannelId *string `json:"channel_id,omitempty"`
}

func (*DescribeChannel) String() string {
	return "describe_channel"
}

func (action *DescribeChannel) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "describe_channel",
		},
	}

	if x := action.ChannelId; x != nil {
		clientAction.Params["channel_id"] = *x
	} else {
		return nil, errors.New("describe_channel requires channel_id parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *DescribeChannel) Invoke(session *ninchat.Session) (reply *ChannelFound, err error) {
	var buf ChannelFound

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// DescribeIdentity action.
type DescribeIdentity struct {
	IdentityName *string `json:"identity_name,omitempty"`
	IdentityType *string `json:"identity_type,omitempty"`
}

func (*DescribeIdentity) String() string {
	return "describe_identity"
}

func (action *DescribeIdentity) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "describe_identity",
		},
	}

	if x := action.IdentityName; x != nil {
		clientAction.Params["identity_name"] = *x
	} else {
		return nil, errors.New("describe_identity requires identity_name parameter")
	}

	if x := action.IdentityType; x != nil {
		clientAction.Params["identity_type"] = *x
	} else {
		return nil, errors.New("describe_identity requires identity_type parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *DescribeIdentity) Invoke(session *ninchat.Session) (reply *IdentityFound, err error) {
	var buf IdentityFound

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// DescribeMaster action.
type DescribeMaster struct {
}

func (*DescribeMaster) String() string {
	return "describe_master"
}

func (action *DescribeMaster) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "describe_master",
		},
	}

	return
}

// Invoke the action synchronously.
func (action *DescribeMaster) Invoke(session *ninchat.Session) (reply *MasterFound, err error) {
	var buf MasterFound

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// DescribeQueue action.
type DescribeQueue struct {
	QueueId *string `json:"queue_id,omitempty"`
}

func (*DescribeQueue) String() string {
	return "describe_queue"
}

func (action *DescribeQueue) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "describe_queue",
		},
	}

	if x := action.QueueId; x != nil {
		clientAction.Params["queue_id"] = *x
	} else {
		return nil, errors.New("describe_queue requires queue_id parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *DescribeQueue) Invoke(session *ninchat.Session) (reply *QueueFound, err error) {
	var buf QueueFound

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// DescribeRealm action.
type DescribeRealm struct {
	RealmId *string `json:"realm_id,omitempty"`
}

func (*DescribeRealm) String() string {
	return "describe_realm"
}

func (action *DescribeRealm) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "describe_realm",
		},
	}

	if x := action.RealmId; x != nil {
		clientAction.Params["realm_id"] = *x
	} else {
		return nil, errors.New("describe_realm requires realm_id parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *DescribeRealm) Invoke(session *ninchat.Session) (reply *RealmFound, err error) {
	var buf RealmFound

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// DescribeRealmQueues action.
type DescribeRealmQueues struct {
	RealmId *string `json:"realm_id,omitempty"`
}

func (*DescribeRealmQueues) String() string {
	return "describe_realm_queues"
}

func (action *DescribeRealmQueues) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "describe_realm_queues",
		},
	}

	if x := action.RealmId; x != nil {
		clientAction.Params["realm_id"] = *x
	} else {
		return nil, errors.New("describe_realm_queues requires realm_id parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *DescribeRealmQueues) Invoke(session *ninchat.Session) (reply *RealmQueuesFound, err error) {
	var buf RealmQueuesFound

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// DescribeUser action.
type DescribeUser struct {
	UserId *string `json:"user_id,omitempty"`
}

func (*DescribeUser) String() string {
	return "describe_user"
}

func (action *DescribeUser) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "describe_user",
		},
	}

	if x := action.UserId; x != nil {
		clientAction.Params["user_id"] = *x
	}

	return
}

// Invoke the action synchronously.
func (action *DescribeUser) Invoke(session *ninchat.Session) (reply *UserFound, err error) {
	var buf UserFound

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// DiscardHistory action.
type DiscardHistory struct {
	MessageId *string `json:"message_id,omitempty"`
	UserId    *string `json:"user_id,omitempty"`
}

func (*DiscardHistory) String() string {
	return "discard_history"
}

func (action *DiscardHistory) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "discard_history",
		},
	}

	if x := action.MessageId; x != nil {
		clientAction.Params["message_id"] = *x
	} else {
		return nil, errors.New("discard_history requires message_id parameter")
	}

	if x := action.UserId; x != nil {
		clientAction.Params["user_id"] = *x
	} else {
		return nil, errors.New("discard_history requires user_id parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *DiscardHistory) Invoke(session *ninchat.Session) (reply *HistoryDiscarded, err error) {
	var buf HistoryDiscarded

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// FollowChannel action.
type FollowChannel struct {
	AccessKey *string `json:"access_key,omitempty"`
	ChannelId *string `json:"channel_id,omitempty"`
}

func (*FollowChannel) String() string {
	return "follow_channel"
}

func (action *FollowChannel) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "follow_channel",
		},
	}

	if x := action.AccessKey; x != nil {
		clientAction.Params["access_key"] = *x
	}

	if x := action.ChannelId; x != nil {
		clientAction.Params["channel_id"] = *x
	}

	return
}

// Invoke the action synchronously.
func (action *FollowChannel) Invoke(session *ninchat.Session) (reply *ChannelFound, err error) {
	var buf ChannelFound

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// JoinChannel action.
type JoinChannel struct {
	AccessKey   *string     `json:"access_key,omitempty"`
	ChannelId   *string     `json:"channel_id,omitempty"`
	MasterSign  *string     `json:"master_sign,omitempty"`
	MemberAttrs interface{} `json:"member_attrs"`
}

func (*JoinChannel) String() string {
	return "join_channel"
}

func (action *JoinChannel) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "join_channel",
		},
	}

	if x := action.AccessKey; x != nil {
		clientAction.Params["access_key"] = *x
	}

	if x := action.ChannelId; x != nil {
		clientAction.Params["channel_id"] = *x
	}

	if x := action.MasterSign; x != nil {
		clientAction.Params["master_sign"] = *x
	}

	if x := action.MemberAttrs; x != nil {
		clientAction.Params["member_attrs"] = x
	}

	return
}

// Invoke the action synchronously.
func (action *JoinChannel) Invoke(session *ninchat.Session) (reply *ChannelJoined, err error) {
	var buf ChannelJoined

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// LoadHistory action.
type LoadHistory struct {
	ChannelId       *string  `json:"channel_id,omitempty"`
	FilterProperty  *string  `json:"filter_property,omitempty"`
	FilterSubstring *string  `json:"filter_substring,omitempty"`
	HistoryLength   *int     `json:"history_length,omitempty"`
	HistoryOrder    *int     `json:"history_order,omitempty"`
	MessageId       *string  `json:"message_id,omitempty"`
	MessageTypes    []string `json:"message_types,omitempty"`
	UserId          *string  `json:"user_id,omitempty"`
}

func (*LoadHistory) String() string {
	return "load_history"
}

func (action *LoadHistory) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "load_history",
		},
	}

	if x := action.ChannelId; x != nil {
		clientAction.Params["channel_id"] = *x
	}

	if x := action.FilterProperty; x != nil {
		clientAction.Params["filter_property"] = *x
	}

	if x := action.FilterSubstring; x != nil {
		clientAction.Params["filter_substring"] = *x
	}

	if x := action.HistoryLength; x != nil {
		clientAction.Params["history_length"] = *x
	}

	if x := action.HistoryOrder; x != nil {
		clientAction.Params["history_order"] = *x
	}

	if x := action.MessageId; x != nil {
		clientAction.Params["message_id"] = *x
	}

	if x := action.MessageTypes; len(x) > 0 {
		clientAction.Params["message_types"] = x
	}

	if x := action.UserId; x != nil {
		clientAction.Params["user_id"] = *x
	}

	return
}

// PartChannel action.
type PartChannel struct {
	ChannelId *string `json:"channel_id,omitempty"`
}

func (*PartChannel) String() string {
	return "part_channel"
}

func (action *PartChannel) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "part_channel",
		},
	}

	if x := action.ChannelId; x != nil {
		clientAction.Params["channel_id"] = *x
	} else {
		return nil, errors.New("part_channel requires channel_id parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *PartChannel) Invoke(session *ninchat.Session) (reply *ChannelParted, err error) {
	var buf ChannelParted

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// Ping action.
type Ping struct {
	ActionIdDisabled bool
}

func (*Ping) String() string {
	return "ping"
}

func (action *Ping) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "ping",
		},
	}

	if action.ActionIdDisabled {
		clientAction.Params["action_id"] = nil
	}

	return
}

// Invoke the action synchronously.
func (action *Ping) Invoke(session *ninchat.Session) (reply *Pong, err error) {
	var buf Pong

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// RemoveMember action.
type RemoveMember struct {
	ChannelId *string `json:"channel_id,omitempty"`
	QueueId   *string `json:"queue_id,omitempty"`
	RealmId   *string `json:"realm_id,omitempty"`
	UserId    *string `json:"user_id,omitempty"`
}

func (*RemoveMember) String() string {
	return "remove_member"
}

func (action *RemoveMember) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "remove_member",
		},
	}

	if x := action.ChannelId; x != nil {
		clientAction.Params["channel_id"] = *x
	}

	if x := action.QueueId; x != nil {
		clientAction.Params["queue_id"] = *x
	}

	if x := action.RealmId; x != nil {
		clientAction.Params["realm_id"] = *x
	}

	if x := action.UserId; x != nil {
		clientAction.Params["user_id"] = *x
	} else {
		return nil, errors.New("remove_member requires user_id parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *RemoveMember) Invoke(session *ninchat.Session) (reply *MemberParted, err error) {
	var buf MemberParted

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// RequestAudience action.
type RequestAudience struct {
	AudienceMetadata map[string]interface{} `json:"audience_metadata,omitempty"`
	QueueId          *string                `json:"queue_id,omitempty"`
}

func (*RequestAudience) String() string {
	return "request_audience"
}

func (action *RequestAudience) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "request_audience",
		},
	}

	if x := action.AudienceMetadata; x != nil {
		clientAction.Params["audience_metadata"] = x
	}

	if x := action.QueueId; x != nil {
		clientAction.Params["queue_id"] = *x
	} else {
		return nil, errors.New("request_audience requires queue_id parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *RequestAudience) Invoke(session *ninchat.Session) (reply *AudienceEnqueued, err error) {
	var buf AudienceEnqueued

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// RequestIdentityAuthResetAccess action.
type RequestIdentityAuthResetAccess struct {
	ActionIdDisabled bool
	IdentityName     *string `json:"identity_name,omitempty"`
	IdentityType     *string `json:"identity_type,omitempty"`
}

func (*RequestIdentityAuthResetAccess) String() string {
	return "request_identity_auth_reset_access"
}

func (action *RequestIdentityAuthResetAccess) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "request_identity_auth_reset_access",
		},
	}

	if action.ActionIdDisabled {
		clientAction.Params["action_id"] = nil
	}

	if x := action.IdentityName; x != nil {
		clientAction.Params["identity_name"] = *x
	} else {
		return nil, errors.New("request_identity_auth_reset_access requires identity_name parameter")
	}

	if x := action.IdentityType; x != nil {
		clientAction.Params["identity_type"] = *x
	} else {
		return nil, errors.New("request_identity_auth_reset_access requires identity_type parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *RequestIdentityAuthResetAccess) Invoke(session *ninchat.Session) (reply *AccessCreated, err error) {
	var buf AccessCreated

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// RequestIdentityVerifyAccess action.
type RequestIdentityVerifyAccess struct {
	ActionIdDisabled bool
	IdentityName     *string `json:"identity_name,omitempty"`
	IdentityType     *string `json:"identity_type,omitempty"`
}

func (*RequestIdentityVerifyAccess) String() string {
	return "request_identity_verify_access"
}

func (action *RequestIdentityVerifyAccess) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "request_identity_verify_access",
		},
	}

	if action.ActionIdDisabled {
		clientAction.Params["action_id"] = nil
	}

	if x := action.IdentityName; x != nil {
		clientAction.Params["identity_name"] = *x
	} else {
		return nil, errors.New("request_identity_verify_access requires identity_name parameter")
	}

	if x := action.IdentityType; x != nil {
		clientAction.Params["identity_type"] = *x
	} else {
		return nil, errors.New("request_identity_verify_access requires identity_type parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *RequestIdentityVerifyAccess) Invoke(session *ninchat.Session) (reply *AccessCreated, err error) {
	var buf AccessCreated

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// ResetIdentityAuth action.
type ResetIdentityAuth struct {
	AccessKey       *string `json:"access_key,omitempty"`
	IdentityAuthNew *string `json:"identity_auth_new,omitempty"`
}

func (*ResetIdentityAuth) String() string {
	return "reset_identity_auth"
}

func (action *ResetIdentityAuth) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action":    "reset_identity_auth",
			"action_id": nil,
		},
	}

	if x := action.AccessKey; x != nil {
		clientAction.Params["access_key"] = *x
	} else {
		return nil, errors.New("reset_identity_auth requires access_key parameter")
	}

	if x := action.IdentityAuthNew; x != nil {
		clientAction.Params["identity_auth_new"] = *x
	} else {
		return nil, errors.New("reset_identity_auth requires identity_auth_new parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *ResetIdentityAuth) Invoke(session *ninchat.Session) (reply *IdentityUpdated, err error) {
	var buf IdentityUpdated

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// ResumeSession action.
type ResumeSession struct {
}

func (*ResumeSession) String() string {
	return "resume_session"
}

func (action *ResumeSession) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action":    "resume_session",
			"action_id": nil,
		},
	}

	return
}

// Search action.
type Search struct {
	SearchTerm *string `json:"search_term,omitempty"`
}

func (*Search) String() string {
	return "search"
}

func (action *Search) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "search",
		},
	}

	if x := action.SearchTerm; x != nil {
		clientAction.Params["search_term"] = *x
	} else {
		return nil, errors.New("search requires search_term parameter")
	}

	return
}

// SendAccess action.
type SendAccess struct {
	AccessKey    *string `json:"access_key,omitempty"`
	IdentityName *string `json:"identity_name,omitempty"`
	IdentityType *string `json:"identity_type,omitempty"`
	UserId       *string `json:"user_id,omitempty"`
}

func (*SendAccess) String() string {
	return "send_access"
}

func (action *SendAccess) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "send_access",
		},
	}

	if x := action.AccessKey; x != nil {
		clientAction.Params["access_key"] = *x
	}

	if x := action.IdentityName; x != nil {
		clientAction.Params["identity_name"] = *x
	}

	if x := action.IdentityType; x != nil {
		clientAction.Params["identity_type"] = *x
	}

	if x := action.UserId; x != nil {
		clientAction.Params["user_id"] = *x
	}

	return
}

// Invoke the action synchronously.
func (action *SendAccess) Invoke(session *ninchat.Session) (reply *AccessFound, err error) {
	var buf AccessFound

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// SendMessage action.
type SendMessage struct {
	ActionIdDisabled    bool
	ChannelId           *string  `json:"channel_id,omitempty"`
	IdentityName        *string  `json:"identity_name,omitempty"`
	IdentityType        *string  `json:"identity_type,omitempty"`
	MessageFold         bool     `json:"message_fold,omitempty"`
	MessageRecipientIds []string `json:"message_recipient_ids,omitempty"`
	MessageTtl          *float64 `json:"message_ttl,omitempty"`
	MessageType         *string  `json:"message_type,omitempty"`
	UserId              *string  `json:"user_id,omitempty"`
	Payload             [][]byte
}

func (*SendMessage) String() string {
	return "send_message"
}

func (action *SendMessage) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "send_message",
		},
		Payload: action.Payload,
	}

	if action.ActionIdDisabled {
		clientAction.Params["action_id"] = nil
	}

	if x := action.ChannelId; x != nil {
		clientAction.Params["channel_id"] = *x
	}

	if x := action.IdentityName; x != nil {
		clientAction.Params["identity_name"] = *x
	}

	if x := action.IdentityType; x != nil {
		clientAction.Params["identity_type"] = *x
	}

	if x := action.MessageFold; x {
		clientAction.Params["message_fold"] = x
	}

	if x := action.MessageRecipientIds; len(x) > 0 {
		clientAction.Params["message_recipient_ids"] = x
	}

	if x := action.MessageTtl; x != nil {
		clientAction.Params["message_ttl"] = *x
	}

	if x := action.MessageType; x != nil {
		clientAction.Params["message_type"] = *x
	} else {
		return nil, errors.New("send_message requires message_type parameter")
	}

	if x := action.UserId; x != nil {
		clientAction.Params["user_id"] = *x
	}

	return
}

// Invoke the action synchronously.
func (action *SendMessage) Invoke(session *ninchat.Session) (reply *MessageReceived, err error) {
	var buf MessageReceived

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// UpdateChannel action.
type UpdateChannel struct {
	ChannelAttrs *ChannelAttrs `json:"channel_attrs,omitempty"`
	ChannelId    *string       `json:"channel_id,omitempty"`
}

func (*UpdateChannel) String() string {
	return "update_channel"
}

func (action *UpdateChannel) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "update_channel",
		},
	}

	if x := action.ChannelAttrs; x != nil {
		clientAction.Params["channel_attrs"] = x
	} else {
		return nil, errors.New("update_channel requires channel_attrs parameter")
	}

	if x := action.ChannelId; x != nil {
		clientAction.Params["channel_id"] = *x
	} else {
		return nil, errors.New("update_channel requires channel_id parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *UpdateChannel) Invoke(session *ninchat.Session) (reply *ChannelUpdated, err error) {
	var buf ChannelUpdated

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// UpdateDialogue action.
type UpdateDialogue struct {
	DialogueStatus *string     `json:"dialogue_status,omitempty"`
	MemberAttrs    interface{} `json:"member_attrs"`
	UserId         *string     `json:"user_id,omitempty"`
}

func (*UpdateDialogue) String() string {
	return "update_dialogue"
}

func (action *UpdateDialogue) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "update_dialogue",
		},
	}

	if x := action.DialogueStatus; x != nil {
		clientAction.Params["dialogue_status"] = *x
	}

	if x := action.MemberAttrs; x != nil {
		clientAction.Params["member_attrs"] = x
	}

	if x := action.UserId; x != nil {
		clientAction.Params["user_id"] = *x
	} else {
		return nil, errors.New("update_dialogue requires user_id parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *UpdateDialogue) Invoke(session *ninchat.Session) (reply *DialogueUpdated, err error) {
	var buf DialogueUpdated

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// UpdateIdentity action.
type UpdateIdentity struct {
	IdentityAttrs *IdentityAttrs `json:"identity_attrs,omitempty"`
	IdentityName  *string        `json:"identity_name,omitempty"`
	IdentityType  *string        `json:"identity_type,omitempty"`
}

func (*UpdateIdentity) String() string {
	return "update_identity"
}

func (action *UpdateIdentity) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "update_identity",
		},
	}

	if x := action.IdentityAttrs; x != nil {
		clientAction.Params["identity_attrs"] = x
	} else {
		return nil, errors.New("update_identity requires identity_attrs parameter")
	}

	if x := action.IdentityName; x != nil {
		clientAction.Params["identity_name"] = *x
	} else {
		return nil, errors.New("update_identity requires identity_name parameter")
	}

	if x := action.IdentityType; x != nil {
		clientAction.Params["identity_type"] = *x
	} else {
		return nil, errors.New("update_identity requires identity_type parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *UpdateIdentity) Invoke(session *ninchat.Session) (reply *IdentityUpdated, err error) {
	var buf IdentityUpdated

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// UpdateIdentityAuth action.
type UpdateIdentityAuth struct {
	IdentityAuth    *string `json:"identity_auth,omitempty"`
	IdentityAuthNew *string `json:"identity_auth_new,omitempty"`
	IdentityName    *string `json:"identity_name,omitempty"`
	IdentityType    *string `json:"identity_type,omitempty"`
}

func (*UpdateIdentityAuth) String() string {
	return "update_identity_auth"
}

func (action *UpdateIdentityAuth) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "update_identity_auth",
		},
	}

	if x := action.IdentityAuth; x != nil {
		clientAction.Params["identity_auth"] = *x
	}

	if x := action.IdentityAuthNew; x != nil {
		clientAction.Params["identity_auth_new"] = *x
	} else {
		return nil, errors.New("update_identity_auth requires identity_auth_new parameter")
	}

	if x := action.IdentityName; x != nil {
		clientAction.Params["identity_name"] = *x
	} else {
		return nil, errors.New("update_identity_auth requires identity_name parameter")
	}

	if x := action.IdentityType; x != nil {
		clientAction.Params["identity_type"] = *x
	} else {
		return nil, errors.New("update_identity_auth requires identity_type parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *UpdateIdentityAuth) Invoke(session *ninchat.Session) (reply *IdentityUpdated, err error) {
	var buf IdentityUpdated

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// UpdateMember action.
type UpdateMember struct {
	ChannelId   *string     `json:"channel_id,omitempty"`
	MemberAttrs interface{} `json:"member_attrs"`
	RealmId     *string     `json:"realm_id,omitempty"`
	UserId      *string     `json:"user_id,omitempty"`
}

func (*UpdateMember) String() string {
	return "update_member"
}

func (action *UpdateMember) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "update_member",
		},
	}

	if x := action.ChannelId; x != nil {
		clientAction.Params["channel_id"] = *x
	}

	if x := action.MemberAttrs; x != nil {
		clientAction.Params["member_attrs"] = x
	} else {
		return nil, errors.New("update_member requires member_attrs parameter")
	}

	if x := action.RealmId; x != nil {
		clientAction.Params["realm_id"] = *x
	}

	if x := action.UserId; x != nil {
		clientAction.Params["user_id"] = *x
	} else {
		return nil, errors.New("update_member requires user_id parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *UpdateMember) Invoke(session *ninchat.Session) (reply *MemberUpdated, err error) {
	var buf MemberUpdated

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// UpdateMessage action.
type UpdateMessage struct {
	ChannelId     *string `json:"channel_id,omitempty"`
	MessageHidden bool    `json:"message_hidden,omitempty"`
	MessageId     *string `json:"message_id,omitempty"`
}

func (*UpdateMessage) String() string {
	return "update_message"
}

func (action *UpdateMessage) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "update_message",
		},
	}

	if x := action.ChannelId; x != nil {
		clientAction.Params["channel_id"] = *x
	} else {
		return nil, errors.New("update_message requires channel_id parameter")
	}

	if x := action.MessageHidden; x {
		clientAction.Params["message_hidden"] = x
	} else {
		return nil, errors.New("update_message requires message_hidden parameter")
	}

	if x := action.MessageId; x != nil {
		clientAction.Params["message_id"] = *x
	} else {
		return nil, errors.New("update_message requires message_id parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *UpdateMessage) Invoke(session *ninchat.Session) (reply *MessageUpdated, err error) {
	var buf MessageUpdated

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// UpdateQueue action.
type UpdateQueue struct {
	QueueAttrs *QueueAttrs `json:"queue_attrs,omitempty"`
	QueueId    *string     `json:"queue_id,omitempty"`
}

func (*UpdateQueue) String() string {
	return "update_queue"
}

func (action *UpdateQueue) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "update_queue",
		},
	}

	if x := action.QueueAttrs; x != nil {
		clientAction.Params["queue_attrs"] = x
	} else {
		return nil, errors.New("update_queue requires queue_attrs parameter")
	}

	if x := action.QueueId; x != nil {
		clientAction.Params["queue_id"] = *x
	} else {
		return nil, errors.New("update_queue requires queue_id parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *UpdateQueue) Invoke(session *ninchat.Session) (reply *QueueUpdated, err error) {
	var buf QueueUpdated

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// UpdateRealm action.
type UpdateRealm struct {
	RealmAttrs *RealmAttrs `json:"realm_attrs,omitempty"`
	RealmId    *string     `json:"realm_id,omitempty"`
}

func (*UpdateRealm) String() string {
	return "update_realm"
}

func (action *UpdateRealm) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "update_realm",
		},
	}

	if x := action.RealmAttrs; x != nil {
		clientAction.Params["realm_attrs"] = x
	} else {
		return nil, errors.New("update_realm requires realm_attrs parameter")
	}

	if x := action.RealmId; x != nil {
		clientAction.Params["realm_id"] = *x
	} else {
		return nil, errors.New("update_realm requires realm_id parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *UpdateRealm) Invoke(session *ninchat.Session) (reply *RealmUpdated, err error) {
	var buf RealmUpdated

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// UpdateSession action.
type UpdateSession struct {
	ChannelId   *string `json:"channel_id,omitempty"`
	MessageId   *string `json:"message_id,omitempty"`
	SessionIdle bool    `json:"session_idle,omitempty"`
	UserId      *string `json:"user_id,omitempty"`
}

func (*UpdateSession) String() string {
	return "update_session"
}

func (action *UpdateSession) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action":    "update_session",
			"action_id": nil,
		},
	}

	if x := action.ChannelId; x != nil {
		clientAction.Params["channel_id"] = *x
	}

	if x := action.MessageId; x != nil {
		clientAction.Params["message_id"] = *x
	}

	if x := action.SessionIdle; x {
		clientAction.Params["session_idle"] = x
	}

	if x := action.UserId; x != nil {
		clientAction.Params["user_id"] = *x
	}

	return
}

// UpdateUser action.
type UpdateUser struct {
	PayloadAttrs []string               `json:"payload_attrs,omitempty"`
	UserAttrs    *UserAttrs             `json:"user_attrs,omitempty"`
	UserSettings map[string]interface{} `json:"user_settings,omitempty"`
	Payload      [][]byte
}

func (*UpdateUser) String() string {
	return "update_user"
}

func (action *UpdateUser) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "update_user",
		},
		Payload: action.Payload,
	}

	if x := action.PayloadAttrs; len(x) > 0 {
		clientAction.Params["payload_attrs"] = x
	}

	if x := action.UserAttrs; x != nil {
		clientAction.Params["user_attrs"] = x
	}

	if x := action.UserSettings; x != nil {
		clientAction.Params["user_settings"] = x
	}

	return
}

// Invoke the action synchronously.
func (action *UpdateUser) Invoke(session *ninchat.Session) (reply *UserUpdated, err error) {
	var buf UserUpdated

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}

// VerifyIdentity action.
type VerifyIdentity struct {
	ActionIdDisabled bool
	AccessKey        *string `json:"access_key,omitempty"`
	IdentityAccept   bool    `json:"identity_accept,omitempty"`
}

func (*VerifyIdentity) String() string {
	return "verify_identity"
}

func (action *VerifyIdentity) newClientAction() (clientAction *ninchat.Action, err error) {
	clientAction = &ninchat.Action{
		Params: map[string]interface{}{
			"action": "verify_identity",
		},
	}

	if action.ActionIdDisabled {
		clientAction.Params["action_id"] = nil
	}

	if x := action.AccessKey; x != nil {
		clientAction.Params["access_key"] = *x
	} else {
		return nil, errors.New("verify_identity requires access_key parameter")
	}

	if x := action.IdentityAccept; x {
		clientAction.Params["identity_accept"] = x
	} else {
		return nil, errors.New("verify_identity requires identity_accept parameter")
	}

	return
}

// Invoke the action synchronously.
func (action *VerifyIdentity) Invoke(session *ninchat.Session) (reply *IdentityUpdated, err error) {
	var buf IdentityUpdated

	ok, err := unaryCall(session, action, &buf)
	if err != nil {
		return nil, err
	}

	if ok {
		return &buf, nil
	}

	return nil, nil
}
